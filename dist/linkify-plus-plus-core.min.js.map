{"version":3,"file":"linkify-plus-plus-core.min.js","sources":["../node_modules/multi-re/index.js","../lib/rx.js","../lib/url-matcher.js","../node_modules/event-lite/event-lite.mjs","../lib/linkifier.js"],"sourcesContent":["/**\n * Evaluate the replacement string/function with the given match and group info.\n *\n * @param {string|Function} repl - The replacement string or function.\n * @param {RegExpMatchArray} match - The match array.\n * @param {{offset: number, length?: number}} groupInfo - Information about the capturing groups. If repl is a string, length is optional.\n * @returns {string} The result.\n */\nexport function evalRepl(repl, match, groupInfo) {\n  if (typeof repl === 'function') {\n    return repl(match[0], ...match.slice(groupInfo.offset + 1, groupInfo.offset + 1 + groupInfo.length));\n  }\n  return repl.replace(/\\$([0-9]+|&)/g, (_, g1) => {\n    if (g1 === '&') {\n      return match[0];\n    }\n    const index = Number(g1);\n    return match[groupInfo.offset + index] || '';\n  });\n}\n\n/**\n * @typedef {object} GroupInfo\n * @property {string[]} names - The names of the capturing groups.\n * @property {number} length - The number of capturing groups.\n * @property {number} offset - The offset of the group indexes in the combined RegExp. Use `match[info.offset + n]` to access the nth capturing group of the pattern. When `captureAll` is true, `match[info.offset + 0]` is the extra capturing group added to detect which pattern matched.\n */\n\n/**\n * @typedef {object} CompileOptions\n * @property {string} [flags] - The flags for the RegExp.\n * @property {boolean} [captureAll] - If true (default), add capture group to each pattern to detect which pattern matched.\n * @property {string} [prefix] - Prefix the entire regex. This shouldn't contain capturing groups.\n * @property {string} [suffix] - Suffix the entire regex. This shouldn't contain capturing groups.\n */\n\n/**\n * Compiles multiple patterns into a single RegExp.\n *\n * @param {Array<string>} patterns - An array of regex pattern strings.\n * @param {string|CompileOptions} [flagsOrOptions] - Optional flags for the RegExp.\n * @returns {[RegExp, groupInfos: GroupInfo[]]} A RegExp that matches any of the provided patterns. groupInfos contains information about the capturing groups of each pattern.\n */\nexport function compile(patterns, flagsOrOptions) {\n  let options;\n  if (typeof flagsOrOptions === 'string' || flagsOrOptions === undefined) {\n    options = {flags: flagsOrOptions};\n  } else {\n    options = flagsOrOptions;\n  }\n  if (options.captureAll === undefined) {\n    options.captureAll = true;\n  }\n  const infos = patterns.map(p => analyzeRe(p));\n  infos[0].offset = options.captureAll ? 1 : 0;\n  for (let i = 1; i < infos.length; i++) {\n    infos[i].offset = infos[i - 1].offset + infos[i - 1].length + (options.captureAll ? 1 : 0);\n  }\n  for (let i = 0; i < patterns.length; i++) {\n    // rewrite backreferences in pattern\n    patterns[i] = patterns[i].replace(/\\\\(\\d+)/g, (match, g1) => {\n      const originalIndex = Number(g1);\n      const newIndex = originalIndex + infos[i].offset;\n      return `\\\\${newIndex}`;\n    });\n  }\n  let pattern = patterns.map((pat) => {\n    if (options.captureAll) {\n      return `(${pat})`;\n    }\n    return pat;\n  }).join('|');\n  if (options.prefix || options.suffix) {\n    pattern = `${options.prefix || ''}(?:${pattern})${options.suffix || ''}`;\n  }\n  const rx = new RegExp(pattern, options.flags);\n  return [rx, infos];\n}\n\nfunction analyzeRe(source) {\n  const re = new RegExp(source + '|');\n  const match = re.exec('');\n  return {\n    names: re.groups ? Object.keys(re.groups) : [],\n    length: match.length - 1,\n    offset: 0,\n  };\n}\n\n/**\n * Creates a multi RegExp executor that can execute multiple regexps on the same string then return the earliest match.\n *\n * The matching speed is slower than combining the regexps into one when the string is very long. On the other hand, it can be faster when the string is short and there are many regexps to match so searching patternIndex is slow in compiled regex.\n *\n * @param {RegExp[]} rxs - An array of RegExp objects. They should have the 'g' flag set.\n * @returns {{exec: function(string): RegExpMatchArray|null, lastRx: RegExp, lastIndex: number}} An object with an exec method.\n */\nexport function multiReExecutor(rxs) {\n  const cases = rxs.map(rx => ({rx, done: false, match: null}));\n  const self = {exec, lastRx: null, lastIndex: 0};\n  return self;\n\n  function exec(s) {\n    let match = null;\n    for (const c of cases) {\n      if (c.done) {\n        continue;\n      }\n      if (c.match && c.match.index < self.lastIndex || !c.match) {\n        // the cached match is before lastIndex, skip it\n        c.rx.lastIndex = self.lastIndex;\n        c.match = c.rx.exec(s);\n      }\n      if (!c.match) {\n        c.done = true;\n        continue;\n      }\n      if (!match || c.match.index < match.index) {\n        match = c.match;\n        self.lastRx = c.rx;\n      }\n    }\n    if (match) {\n      self.lastIndex = match.index + match[0].length;\n      return match;\n    }\n    self.lastIndex = 0;\n    for (const c of cases) {\n      c.done = false;\n    }\n    return null;\n  }\n}\n","var tlds = require(\"./tlds.json\");\r\n\r\nmodule.exports = {\r\n  IMAGE: /^[^?#]+\\.(?:jpg|jpeg|png|apng|gif|svg|webp|avif)(?:$|[?#])/i,\r\n  PROTOCOL: /([a-z][-a-z*]+:\\/\\/)?/i,\r\n  USER: /(?:([\\w:.+-]+)@)?/i,\r\n  DOMAIN_UNI: new RegExp(String.raw`([a-z0-9-.\\u00A0-\\uFFFF]+\\.[a-z0-9-${tlds.chars}]{1,${tlds.maxLength}})`, \"i\"),\r\n  DOMAIN: new RegExp(String.raw`([a-z0-9-.]+\\.[a-z0-9-]{1,${tlds.maxLength}})`, \"i\"),\r\n  PORT: /(:\\d+\\b)?/,\r\n  PATH_UNI: /([/?#]\\S*)?/,\r\n  PATH: /([/?#][\\w-.~!$&*+;=:@%/?#(),'[\\]]*)?/\r\n};\r\n\r\nmodule.exports.URL = new RegExp(String.raw`https?://${module.exports.USER.source}${module.exports.DOMAIN.source}${module.exports.PORT.source}${module.exports.PATH.source}`, \"i\");\r\n\r\n","const {compile, evalRepl} = require(\"multi-re\");\nconst RXS = require(\"./rx\");\nconst TLD_TABLE = require(\"./tlds.json\").table;\nconst RE = {};\n\nfor (const key in RXS) {\n  RE[key] = RXS[key].source;\n}\n\nfunction regexEscape(text) {\n\treturn text.replace(/[[\\]\\\\^-]/g, \"\\\\$&\");\n}\n\nfunction buildRegex({\n\tunicode = false, customRules = [], standalone = false,\n\tboundaryLeft, boundaryRight, ignoreMustache = false\n}) {\n\tvar pattern = RE.PROTOCOL + RE.USER;\n\t\n\tif (unicode) {\n\t\tpattern += RE.DOMAIN_UNI + RE.PORT + RE.PATH_UNI;\n\t} else {\n\t\tpattern += RE.DOMAIN + RE.PORT + RE.PATH;\n\t}\n\t\n\tvar prefix, suffix, invalidSuffix;\n\tif (standalone) {\n\t\tif (boundaryLeft) {\n\t\t\tprefix = \"(?:^|\\\\s)[\" + regexEscape(boundaryLeft) + \"]*\";\n\t\t} else {\n\t\t\tprefix = \"(?:^|\\\\s)\";\n\t\t}\n\t\tif (boundaryRight) {\n\t\t\tsuffix = \"[\" + regexEscape(boundaryRight) + \"]*(?:$|\\\\s)\";\n\t\t} else {\n\t\t\tsuffix = \"(?:$|\\\\s)\";\n\t\t}\n\t\tinvalidSuffix = \"[^\\\\s\" + regexEscape(boundaryRight) + \"]\";\n\t} else {\n\t\tprefix = \"\\\\b\"; // NOTE: \\b won't match between non-word characters (e.g. / or .) so we don't use it in suffix\n\t\tsuffix = \"\";\n\t}\n\n  const [rx, groupInfos] = compile([\n    ...customRules.map(r => `(${prefix})(${r.pattern})(${suffix})`),\n    ignoreMustache ? /(\\{\\{[\\s\\S]+?\\}\\})/.source : '((?!))',\n    `(${prefix})${pattern}(${suffix})`\n  ], {\n    flags: \"igm\",\n    captureAll: false\n  });\n\treturn {\n    url: rx,\n    groupInfos,\n\t\tinvalidSuffix: invalidSuffix && new RegExp(invalidSuffix),\n\t};\n}\n\nfunction pathStrip(m, re, repl) {\n\tvar s = m.path.replace(re, repl);\n\n\tif (s == m.path) return;\n\t\n\tm.end -= m.path.length - s.length;\n\tm.suffix = m.path.slice(s.length) + m.suffix;\n\tm.path = s;\n}\n\nfunction pathStripQuote(m, c) {\n\tvar i = 0, s = m.path, end, pos = 0;\n\t\n\tif (!s.endsWith(c)) return;\n\t\n\twhile ((pos = s.indexOf(c, pos)) >= 0) {\n\t\tif (i % 2) {\n\t\t\tend = null;\n\t\t} else {\n\t\t\tend = pos;\n\t\t}\n\t\tpos++;\n\t\ti++;\n\t}\n\t\n\tif (!end) return;\n\t\n\tm.end -= s.length - end;\n\tm.path = s.slice(0, end);\n\tm.suffix = s.slice(end) + m.suffix;\n}\n\nfunction pathStripBrace(m, left, right) {\n\tvar str = m.path,\n\t\tre = new RegExp(\"[\\\\\" + left + \"\\\\\" + right + \"]\", \"g\"),\n\t\tmatch, count = 0, end;\n\n\t// Match loop\n\twhile ((match = re.exec(str))) {\n\t\tif (count % 2 == 0) {\n\t\t\tend = match.index;\n\t\t\tif (match[0] == right) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (match[0] == left) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcount++;\n\t}\n\n\tif (!match && count % 2 == 0) {\n\t\treturn;\n\t}\n\t\n\tm.end -= m.path.length - end;\n\tm.path = str.slice(0, end);\n\tm.suffix = str.slice(end) + m.suffix;\n}\n\nfunction isIP(s) {\n\tvar m, i;\n\tif (!(m = s.match(/^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$/))) {\n\t\treturn false;\n\t}\n\tfor (i = 1; i < m.length; i++) {\n\t\tif (+m[i] > 255 || (m[i].length > 1 && m[i][0] == \"0\")) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction inTLDS(domain) {\n\tvar match = domain.match(/\\.([^.]+)$/);\n\tif (!match) {\n\t\treturn false;\n\t}\n\tvar key = match[1].toLowerCase();\n  // eslint-disable-next-line no-prototype-builtins\n\treturn TLD_TABLE.hasOwnProperty(key);\n}\n\nclass UrlMatcher {\n\tconstructor(options = {}) {\n    if (options.customRules) {\n      options.customRules = options.customRules.map(rule => {\n        if (typeof rule === \"string\") {\n          return {\n            pattern: rule,\n            replace: null\n          }\n        }\n        return {\n          pattern: rule.pattern,\n          replace: rule.replace || null\n        }\n      });\n    }\n\n\t\tthis.options = options;\n\t\tthis.regex = buildRegex(options);\n\t}\n\t\n\t*match(text) {\n\t\tvar {\n\t\t\t\tfuzzyIp = true,\n        mail = true\n\t\t\t} = this.options,\n\t\t\t{\n\t\t\t\turl,\n        groupInfos,\n\t\t\t\tinvalidSuffix,\n\t\t\t} = this.regex,\n\t\t\turlLastIndex;\n\t\t\t\n\t\turl.lastIndex = 0;\n\t\t\n\t\tvar urlMatch;\n    const urlGroupOffset = groupInfos[groupInfos.length - 1].offset;\n    const mustacheGroupOffset = groupInfos[groupInfos.length - 2].offset;\n\t\twhile ((urlMatch = url.exec(text))) {\n      const result = {\n        custom: false,\n\n        start: urlMatch.index,\n        end: url.lastIndex,\n        \n        text: \"\",\n        url: \"\",\n\n        prefix: urlMatch[urlGroupOffset + 1] || \"\", // NOTE: this prefix/suffix only exists when url is matched\n        protocol: urlMatch[urlGroupOffset + 2] || \"\",\n        auth: urlMatch[urlGroupOffset + 3] || \"\",\n        domain: urlMatch[urlGroupOffset + 4] || \"\",\n        port: urlMatch[urlGroupOffset + 5] || \"\",\n        path: urlMatch[urlGroupOffset + 6] || \"\",\n        suffix: urlMatch[urlGroupOffset + 7] || \"\",\n\n        mustache: urlMatch[mustacheGroupOffset + 1] || null,\n      };\n\n      if (result.mustache) {\n        // mustache matched, skip\n        continue;\n      }\n      \n      if (!result.domain) {\n        // custom rule matched\n        const patternIndex = groupInfos.findIndex(gi => {\n          return urlMatch[gi.offset + 2] !== undefined;\n        });\n        const gi = groupInfos[patternIndex];\n        result.custom = true;\n        result.start += urlMatch[gi.offset + 1].length; // prefix\n        result.end -= urlMatch[gi.offset + gi.length].length; // suffix\n        result.text = urlMatch[gi.offset + 2]; // middle\n        let url;\n        const customRule = this.options.customRules[patternIndex];\n        if (customRule.replace) {\n          url = evalRepl(customRule.replace, urlMatch, {\n            offset: gi.offset + 2 // skip prefix and middle group\n          });\n        } else {\n          url = result.text;\n        }\n        result.url = url;\n\t\t\t} else {\n        result.start += result.prefix.length;\n        result.end -= result.suffix.length;\n\t\t\t\t// adjust path and suffix\n\t\t\t\tif (result.path) {\n\t\t\t\t\t// Strip BBCode\n\t\t\t\t\tpathStrip(result, /\\[\\/?(b|i|u|url|img|quote|code|size|color)\\].*/i, \"\");\n\t\t\t\t\t\n\t\t\t\t\t// Strip braces\n\t\t\t\t\tpathStripBrace(result, \"(\", \")\");\n\t\t\t\t\tpathStripBrace(result, \"[\", \"]\");\n\t\t\t\t\tpathStripBrace(result, \"{\", \"}\");\n\t\t\t\t\t\n\t\t\t\t\t// Strip quotes\n\t\t\t\t\tpathStripQuote(result, \"'\");\n\t\t\t\t\tpathStripQuote(result, '\"');\n\t\t\t\t\t\n\t\t\t\t\t// Remove trailing \".,?\"\n\t\t\t\t\tpathStrip(result, /(^|[^-_])[.,?]+$/, \"$1\");\n\t\t\t\t}\n\t\t\t\t\n        // FIXME: what is this?\n\t\t\t\t// check suffix\n\t\t\t\tif (invalidSuffix && invalidSuffix.test(result.suffix)) {\n\t\t\t\t\tif (/\\s$/.test(result.suffix)) {\n\t\t\t\t\t\turl.lastIndex--;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n        \n        // ignore fuzzy ip\n\t\t\t\tif (!fuzzyIp && isIP(result.domain) &&\n            !result.protocol && !result.auth && !result.path) {\n          continue;\n        }\n        \n\t\t\t\t// mailto protocol\n\t\t\t\tif (!result.protocol && result.auth) {\n\t\t\t\t\tvar matchMail = result.auth.match(/^mailto:(.+)/);\n\t\t\t\t\tif (matchMail) {\n\t\t\t\t\t\tresult.protocol = \"mailto:\";\n\t\t\t\t\t\tresult.auth = matchMail[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// http alias\n\t\t\t\tif (result.protocol && result.protocol.match(/^(hxxp|h\\*\\*p|ttp)/)) {\n\t\t\t\t\tresult.protocol = \"http://\";\n\t\t\t\t}\n\n\t\t\t\t// guess protocol\n\t\t\t\tif (!result.protocol) {\n\t\t\t\t\tvar domainMatch;\n\t\t\t\t\tif ((domainMatch = result.domain.match(/^(ftp|irc)/))) {\n\t\t\t\t\t\tresult.protocol = domainMatch[0] + \"://\";\n\t\t\t\t\t} else if (result.domain.match(/^(www|web)/)) {\n\t\t\t\t\t\tresult.protocol = \"http://\";\n\t\t\t\t\t} else if (result.auth && result.auth.indexOf(\":\") < 0 && !result.path) {\n\t\t\t\t\t\tresult.protocol = \"mailto:\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.protocol = \"http://\";\n\t\t\t\t\t}\n\t\t\t\t}\n        \n        // ignore mail\n        if (!mail && result.protocol === \"mailto:\") {\n          continue;\n        }\n        \n\t\t\t\t// verify domain\n        if (!isIP(result.domain)) {\n          if (/^(http|https|mailto)/.test(result.protocol) && !inTLDS(result.domain)) {\n            continue;\n          }\n          \n          const invalidLabel = getInvalidLabel(result.domain);\n          if (invalidLabel) {\n            url.lastIndex = urlMatch.index + invalidLabel.index + 1;\n            continue;\n          }\n        }\n\n\t\t\t\t// Create URL\n\t\t\t\tresult.url = result.protocol + (result.auth && result.auth + \"@\") + result.domain + result.port + result.path;\n\t\t\t\tresult.text = text.slice(result.start, result.end);\n\t\t\t}\n\t\t\t\n\t\t\t// since regex is shared with other parse generators, cache lastIndex position and restore later\n\t\t\turlLastIndex = url.lastIndex;\n\t\t\t\n\t\t\tyield result;\n\t\t\t\n\t\t\turl.lastIndex = urlLastIndex;\n\t\t}\n\t}\n}\n\nfunction getInvalidLabel(domain) {\n  // https://tools.ietf.org/html/rfc1035\n  // https://serverfault.com/questions/638260/is-it-valid-for-a-hostname-to-start-with-a-digit\n  let index = 0;\n  const parts = domain.split(\".\");\n  for (const part of parts) {\n    if (\n      !part ||\n      part.startsWith(\"-\") ||\n      part.endsWith(\"-\")\n    ) {\n      return {\n        index,\n        value: part\n      };\n    }\n    index += part.length + 1;\n  }\n}\n\nmodule.exports = {\n\tUrlMatcher\n};\n","/**\n * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)\n *\n * @copyright Yusuke Kawasaki\n * @license MIT\n * @constructor\n * @see https://github.com/kawanet/event-lite\n * @see http://kawanet.github.io/event-lite/EventLite.html\n * @example\n * var EventLite = require(\"event-lite\");\n *\n * function MyClass() {...}             // your class\n *\n * EventLite.mixin(MyClass.prototype);  // import event methods\n *\n * var obj = new MyClass();\n * obj.on(\"foo\", function() {...});     // add event listener\n * obj.once(\"bar\", function() {...});   // add one-time event listener\n * obj.emit(\"foo\");                     // dispatch event\n * obj.emit(\"bar\");                     // dispatch another event\n * obj.off(\"foo\");                      // remove event listener\n */\n\nexport default function EventLite() {\n  if (!(this instanceof EventLite)) return new EventLite();\n}\n\n// (function(EventLite) {\n  // export the class for node.js\n  // if (\"undefined\" !== typeof module) module.exports = EventLite;\n\n  // property name to hold listeners\n  var LISTENERS = \"listeners\";\n\n  // methods to export\n  var methods = {\n    on: on,\n    once: once,\n    off: off,\n    emit: emit\n  };\n\n  // mixin to self\n  mixin(EventLite.prototype);\n\n  // export mixin function\n  EventLite.mixin = mixin;\n\n  /**\n   * Import on(), once(), off() and emit() methods into target object.\n   *\n   * @function EventLite.mixin\n   * @param target {Prototype}\n   */\n\n  function mixin(target) {\n    for (var key in methods) {\n      target[key] = methods[key];\n    }\n    return target;\n  }\n\n  /**\n   * Add an event listener.\n   *\n   * @function EventLite.prototype.on\n   * @param type {string}\n   * @param func {Function}\n   * @returns {EventLite} Self for method chaining\n   */\n\n  function on(type, func) {\n    getListeners(this, type).push(func);\n    return this;\n  }\n\n  /**\n   * Add one-time event listener.\n   *\n   * @function EventLite.prototype.once\n   * @param type {string}\n   * @param func {Function}\n   * @returns {EventLite} Self for method chaining\n   */\n\n  function once(type, func) {\n    var that = this;\n    wrap.originalListener = func;\n    getListeners(that, type).push(wrap);\n    return that;\n\n    function wrap() {\n      off.call(that, type, wrap);\n      func.apply(this, arguments);\n    }\n  }\n\n  /**\n   * Remove an event listener.\n   *\n   * @function EventLite.prototype.off\n   * @param [type] {string}\n   * @param [func] {Function}\n   * @returns {EventLite} Self for method chaining\n   */\n\n  function off(type, func) {\n    var that = this;\n    var listners;\n    if (!arguments.length) {\n      delete that[LISTENERS];\n    } else if (!func) {\n      listners = that[LISTENERS];\n      if (listners) {\n        delete listners[type];\n        if (!Object.keys(listners).length) return off.call(that);\n      }\n    } else {\n      listners = getListeners(that, type, true);\n      if (listners) {\n        listners = listners.filter(ne);\n        if (!listners.length) return off.call(that, type);\n        that[LISTENERS][type] = listners;\n      }\n    }\n    return that;\n\n    function ne(test) {\n      return test !== func && test.originalListener !== func;\n    }\n  }\n\n  /**\n   * Dispatch (trigger) an event.\n   *\n   * @function EventLite.prototype.emit\n   * @param type {string}\n   * @param [value] {*}\n   * @returns {boolean} True when a listener received the event\n   */\n\n  function emit(type, value) {\n    var that = this;\n    var listeners = getListeners(that, type, true);\n    if (!listeners) return false;\n    var arglen = arguments.length;\n    if (arglen === 1) {\n      listeners.forEach(zeroarg);\n    } else if (arglen === 2) {\n      listeners.forEach(onearg);\n    } else {\n      var args = Array.prototype.slice.call(arguments, 1);\n      listeners.forEach(moreargs);\n    }\n    return !!listeners.length;\n\n    function zeroarg(func) {\n      func.call(that);\n    }\n\n    function onearg(func) {\n      func.call(that, value);\n    }\n\n    function moreargs(func) {\n      func.apply(that, args);\n    }\n  }\n\n  /**\n   * @ignore\n   */\n\n  function getListeners(that, type, readonly) {\n    if (readonly && !that[LISTENERS]) return;\n    var listeners = that[LISTENERS] || (that[LISTENERS] = {});\n    return listeners[type] || (listeners[type] = []);\n  }\n\n// })(EventLite);\n","/* eslint-env browser */\n\nvar Events = require(\"event-lite\");\nconst {IMAGE} = require(\"./rx\");\n\nvar INVALID_TAGS = {\n\ta: true,\n\tnoscript: true,\n\toption: true,\n\tscript: true,\n\tstyle: true,\n\ttextarea: true,\n\tsvg: true,\n\tcanvas: true,\n\tbutton: true,\n\tselect: true,\n\ttemplate: true,\n\tmeter: true,\n\tprogress: true,\n\tmath: true,\n\ttime: true\n};\n\nclass Pos {\n\tconstructor(container, offset, i = 0) {\n\t\tthis.container = container;\n\t\tthis.offset = offset;\n\t\tthis.i = i;\n\t}\n\t\n\tadd(change) {\n\t\tvar cont = this.container,\n\t\t\toffset = this.offset;\n\n\t\tthis.i += change;\n\t\t\n\t\t// If the container is #text.parentNode\n\t\tif (cont.childNodes.length) {\n\t\t\tcont = cont.childNodes[offset];\n\t\t\toffset = 0;\n\t\t}\n\n\t\t// If the container is #text\n\t\twhile (cont) {\n\t\t\tif (cont.nodeType == 3) {\n\t\t\t\tif (!cont.LEN) {\n\t\t\t\t\tcont.LEN = cont.nodeValue.length;\n\t\t\t\t}\n\t\t\t\tif (offset + change <= cont.LEN) {\n\t\t\t\t\tthis.container = cont;\n\t\t\t\t\tthis.offset = offset + change;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tchange = offset + change - cont.LEN;\n\t\t\t\toffset = 0;\n\t\t\t}\n\t\t\tcont = cont.nextSibling;\n\t\t}\n\t}\n\t\n\tmoveTo(offset) {\n\t\tthis.add(offset - this.i);\n\t}\n}\n\nfunction cloneContents(range) {\n\tif (range.startContainer == range.endContainer) {\n\t\treturn document.createTextNode(range.toString());\n\t}\n\treturn range.cloneContents();\n}\n\nvar DEFAULT_OPTIONS = {\n\tmaxRunTime: 100,\n\ttimeout: 10000,\n\tnewTab: true,\n\tnoOpener: true,\n\tembedImage: true,\n  recursive: true,\n};\n\nclass Linkifier extends Events {\n\tconstructor(root, options = {}) {\n\t\tsuper();\n\t\tif (!(root instanceof Node)) {\n\t\t\toptions = root;\n\t\t\troot = options.root;\n\t\t}\n\t\tthis.root = root;\n\t\tthis.options = Object.assign({}, DEFAULT_OPTIONS, options);\n\t\tthis.aborted = false;\n\t}\n\tstart() {\n\t\tvar time = Date.now,\n\t\t\tstartTime = time(),\n\t\t\tchunks = this.generateChunks();\n\t\t\t\n\t\tvar next = () => {\n\t\t\tif (this.aborted) {\n\t\t\t\tthis.emit(\"error\", new Error(\"Aborted\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar chunkStart = time(),\n\t\t\t\tnow;\n\t\t\t\t\n\t\t\tdo {\n\t\t\t\tif (chunks.next().done) {\n\t\t\t\t\tthis.emit(\"complete\", time() - startTime);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while ((now = time()) - chunkStart < this.options.maxRunTime);\n\t\t\t\n\t\t\tif (now - startTime > this.options.timeout) {\n\t\t\t\tthis.emit(\"error\", new Error(`max execution time exceeded: ${now - startTime}, on ${this.root}`));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tsetTimeout(next);\n\t\t};\n\t\t\t\n\t\tsetTimeout(next);\n\t}\n\tabort() {\n\t\tthis.aborted = true;\n\t}\n\t*generateRanges() {\n\t\tvar {validator, recursive} = this.options;\n\t\tvar filter = {\n\t\t\tacceptNode: function(node) {\n\t\t\t\tif (validator && !validator(node)) {\n\t\t\t\t\treturn NodeFilter.FILTER_REJECT;\n\t\t\t\t}\n\t\t\t\tif (INVALID_TAGS[node.localName]) {\n\t\t\t\t\treturn NodeFilter.FILTER_REJECT;\n\t\t\t\t}\n\t\t\t\tif (node.localName == \"wbr\") {\n\t\t\t\t\treturn NodeFilter.FILTER_ACCEPT;\n\t\t\t\t}\n\t\t\t\tif (node.nodeType == 3) {\n\t\t\t\t\treturn NodeFilter.FILTER_ACCEPT;\n\t\t\t\t}\n\t\t\t\treturn recursive ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_REJECT;\n\t\t\t}\n\t\t};\n\t\t// Generate linkified ranges.\n\t\tvar walker = document.createTreeWalker(\n\t\t\tthis.root,\n\t\t\tNodeFilter.SHOW_TEXT + NodeFilter.SHOW_ELEMENT,\n\t\t\tfilter\n\t\t), start, end, current, range;\n\n\t\tend = start = walker.nextNode();\n\t\tif (!start) {\n\t\t\treturn;\n\t\t}\n\t\trange = document.createRange();\n\t\trange.setStartBefore(start);\n\t\twhile ((current = walker.nextNode())) {\n\t\t\tif (end.nextSibling == current) {\n\t\t\t\tend = current;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trange.setEndAfter(end);\n\t\t\tyield range;\n\n\t\t\tend = start = current;\n\t\t\trange.setStartBefore(start);\n\t\t}\n\t\trange.setEndAfter(end);\n\t\tyield range;\n\t}\n\t*generateChunks() {\n\t\tvar {matcher} = this.options;\n\t\tfor (var range of this.generateRanges()) {\n\t\t\tvar frag = null,\n\t\t\t\tpos = null,\n\t\t\t\ttext = range.toString(),\n\t\t\t\ttextRange = null;\n\t\t\tfor (var result of matcher.match(text)) {\n\t\t\t\tif (!frag) {\n\t\t\t\t\tfrag = document.createDocumentFragment();\n\t\t\t\t\tpos = new Pos(range.startContainer, range.startOffset);\n\t\t\t\t\ttextRange = range.cloneRange();\n\t\t\t\t}\n\t\t\t\t// clone text\n\t\t\t\tpos.moveTo(result.start);\n\t\t\t\ttextRange.setEnd(pos.container, pos.offset);\n\t\t\t\tfrag.appendChild(cloneContents(textRange));\n\t\t\t\t\n\t\t\t\t// clone link\n\t\t\t\ttextRange.collapse();\n\t\t\t\tpos.moveTo(result.end);\n\t\t\t\ttextRange.setEnd(pos.container, pos.offset);\n\t\t\t\t\n\t\t\t\tvar content = cloneContents(textRange),\n\t\t\t\t\tlink = this.buildLink(result, content);\n\n\t\t\t\ttextRange.collapse();\n\n\t\t\t\tfrag.appendChild(link);\n\t\t\t\tthis.emit(\"link\", {link, range, result, content});\n\t\t\t}\n\t\t\tif (pos) {\n\t\t\t\tpos.moveTo(text.length);\n\t\t\t\ttextRange.setEnd(pos.container, pos.offset);\n\t\t\t\tfrag.appendChild(cloneContents(textRange));\n\t\t\t\t\n\t\t\t\trange.deleteContents();\n\t\t\t\trange.insertNode(frag);\n\t\t\t}\n\t\t\tyield;\n\t\t}\n\t}\n\tbuildLink(result, content) {\n\t\tvar {newTab, embedImage, noOpener} = this.options;\n\t\tvar link = document.createElement(\"a\");\n\t\tlink.href = result.url;\n\t\tlink.title = \"Linkify Plus Plus\";\n\t\tlink.className = \"linkifyplus\";\n\t\tif (newTab) {\n\t\t\tlink.target = \"_blank\";\n\t\t}\n\t\tif (noOpener) {\n\t\t\tlink.rel = \"noopener\";\n\t\t}\n\t\tvar child;\n\t\tif (embedImage && IMAGE.test(result.url)) {\n\t\t\tchild = new Image;\n\t\t\tchild.src = result.url;\n\t\t\tchild.alt = result.text;\n\t\t} else {\n\t\t\tchild = content;\n\t\t}\n\t\tlink.appendChild(child);\n\t\treturn link;\n\t}\n}\n\nfunction linkify(...args) {\n\treturn new Promise((resolve, reject) => {\n\t\tvar linkifier = new Linkifier(...args);\n\t\tlinkifier.on(\"error\", reject);\n\t\tlinkifier.on(\"complete\", resolve);\n\t\tfor (var key of Object.keys(linkifier.options)) {\n\t\t\tif (key.startsWith(\"on\")) {\n\t\t\t\tlinkifier.on(key.slice(2), linkifier.options[key]);\n\t\t\t}\n\t\t}\n\t\tlinkifier.start();\n\t});\n}\n\nmodule.exports = {\n\tINVALID_TAGS,\n\tLinkifier,\n\tlinkify\n};\n"],"names":["evalRepl","repl","match","groupInfo","slice","offset","length","replace","_","g1","index","Number","_module_exports_","IMAGE","PROTOCOL","USER","DOMAIN_UNI","RegExp","String","raw","DOMAIN","PORT","PATH_UNI","PATH","URL","source","RE","key","RXS","regexEscape","text","pathStrip","m","re","s","path","end","suffix","pathStripQuote","c","i","pos","endsWith","indexOf","pathStripBrace","left","right","str","count","exec","isIP","inTLDS","domain","toLowerCase","TLD_TABLE","hasOwnProperty","getInvalidLabel","parts","split","part","startsWith","value","EventLite","this","LISTENERS","methods","on","type","func","getListeners","push","once","that","wrap","originalListener","off","call","apply","arguments","emit","listeners","arglen","forEach","args","Array","prototype","mixin","target","listners","filter","test","Object","keys","readonly","_require__$rx_","INVALID_TAGS","a","noscript","option","script","style","textarea","svg","canvas","button","select","template","meter","progress","math","time","Pos","constructor","container","add","change","cont","childNodes","nodeType","LEN","nodeValue","nextSibling","moveTo","cloneContents","range","startContainer","endContainer","document","createTextNode","toString","DEFAULT_OPTIONS","maxRunTime","timeout","newTab","noOpener","embedImage","recursive","Linkifier","Events","root","options","super","Node","assign","aborted","start","Date","now","startTime","chunks","generateChunks","next","Error","chunkStart","done","setTimeout","abort","generateRanges","current","validator","acceptNode","node","localName","NodeFilter","FILTER_REJECT","FILTER_ACCEPT","FILTER_SKIP","walker","createTreeWalker","SHOW_TEXT","SHOW_ELEMENT","nextNode","createRange","setStartBefore","setEndAfter","matcher","frag","textRange","result","createDocumentFragment","startOffset","cloneRange","setEnd","appendChild","collapse","content","link","buildLink","deleteContents","insertNode","child","createElement","href","url","title","className","rel","Image","src","alt","customRules","map","rule","pattern","regex","unicode","standalone","boundaryLeft","boundaryRight","ignoreMustache","prefix","invalidSuffix","rx","groupInfos","patterns","flagsOrOptions","undefined","flags","captureAll","infos","p","names","groups","analyzeRe","pat","join","compile","r","buildRegex","urlLastIndex","urlMatch","fuzzyIp","mail","lastIndex","urlGroupOffset","mustacheGroupOffset","custom","protocol","auth","port","mustache","matchMail","domainMatch","invalidLabel","patternIndex","findIndex","gi","customRule","Promise","resolve","reject","linkifier"],"mappings":"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","x_google_ignoreList":[0,3]}